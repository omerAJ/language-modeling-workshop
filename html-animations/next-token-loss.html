<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>How Language Models Learn — Next-Token Prediction</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  :root {
    --bg: #0f1117;
    --surface: #1a1d27;
    --surface2: #242836;
    --border: #2e3345;
    --text: #f3f3f5;
    --text-dim: #8a8fa8;
    --accent: #6c8cff;
    --accent-glow: rgba(108, 140, 255, 0.25);
    --green: #4ade80;
    --green-glow: rgba(74, 222, 128, 0.2);
    --red: #f87171;
    --red-glow: rgba(248, 113, 113, 0.2);
    --orange: #fb923c;
    --purple: #a78bfa;
    --yellow: #facc15;
    --cyan: #22d3ee;
  }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Inter', sans-serif;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    overflow-x: hidden;
  }

  /* ── Header ── */
  .header {
    text-align: center;
    padding: 28px 20px 10px;
  }
  .header h1 {
    font-size: 1.5rem;
    font-weight: 700;
    letter-spacing: -0.02em;
    background: linear-gradient(135deg, var(--accent), var(--purple));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }
  .header p {
    color: var(--text-dim);
    font-size: 0.85rem;
    margin-top: 4px;
  }

  /* ── Stage container ── */
  .stage {
    width: min(960px, 95vw);
    flex: 1;
    position: relative;
    padding: 16px 0 100px;
  }

  /* ── Step indicator ── */
  .step-dots {
    display: flex;
    justify-content: center;
    gap: 8px;
    margin-bottom: 18px;
  }
  .step-dots .dot {
    width: 10px; height: 10px;
    border-radius: 50%;
    background: var(--border);
    transition: all 0.4s;
    cursor: pointer;
  }
  .step-dots .dot.active {
    background: var(--accent);
    box-shadow: 0 0 10px var(--accent-glow);
    transform: scale(1.2);
  }
  .step-dots .dot.done {
    background: var(--green);
  }

  /* ── Panels ── */
  .panel {
    display: none;
    flex-direction: column;
    gap: 20px;
    animation: fadeSlideIn 0.5s ease;
  }
  .panel.active { display: flex; }

  @keyframes fadeSlideIn {
    from { opacity: 0; transform: translateY(18px); }
    to   { opacity: 1; transform: translateY(0); }
  }

  .card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 14px;
    padding: 24px;
    position: relative;
    overflow: hidden;
  }
  .card::before {
    content: '';
    position: absolute;
    inset: 0;
    background: radial-gradient(ellipse at top left, rgba(108,140,255,0.04), transparent 60%);
    pointer-events: none;
  }

  .step-label {
    display: inline-block;
    font-size: 0.7rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    color: var(--accent);
    background: rgba(108,140,255,0.1);
    padding: 3px 10px;
    border-radius: 20px;
    margin-bottom: 10px;
  }

  .card h2 {
    font-size: 1.15rem;
    font-weight: 600;
    margin-bottom: 8px;
  }
  .card .desc {
    color: var(--text-dim);
    font-size: 0.85rem;
    line-height: 1.55;
    max-width: 640px;
  }

  /* ── Context display ── */
  .context-row {
    display: flex;
    align-items: center;
    gap: 6px;
    flex-wrap: wrap;
    margin: 18px 0 6px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 1.15rem;
  }
  .token {
    display: inline-flex;
    align-items: center;
    padding: 6px 14px;
    border-radius: 8px;
    background: var(--surface2);
    border: 1px solid var(--border);
    transition: all 0.3s;
    white-space: nowrap;
  }
  .token.highlight {
    border-color: var(--accent);
    background: rgba(108,140,255,0.12);
  }
  .token.target {
    border-color: var(--green);
    background: rgba(74,222,128,0.12);
    color: var(--green);
    font-weight: 600;
  }
  .token.blank {
    border: 2px dashed var(--orange);
    color: var(--orange);
    min-width: 70px;
    justify-content: center;
    animation: pulse-border 1.5s ease-in-out infinite;
  }
  @keyframes pulse-border {
    0%, 100% { border-color: var(--orange); }
    50% { border-color: rgba(251,146,60,0.3); }
  }

  .arrow-down {
    text-align: center;
    color: var(--text-dim);
    font-size: 1.6rem;
    margin: 4px 0;
    animation: bobDown 1.2s ease-in-out infinite;
  }
  @keyframes bobDown {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(5px); }
  }

  /* ── Network box ── */
  .network-box {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 14px;
    padding: 18px 28px;
    background: linear-gradient(135deg, rgba(108,140,255,0.08), rgba(167,139,250,0.08));
    border: 1px solid rgba(108,140,255,0.2);
    border-radius: 12px;
    margin: 0 auto;
    max-width: 380px;
    position: relative;
  }
  .network-box .nn-icon {
    font-size: 1.8rem;
  }
  .network-box .nn-label {
    font-weight: 600;
    font-size: 0.95rem;
  }
  .network-box .nn-sub {
    font-size: 0.75rem;
    color: var(--text-dim);
  }
  .network-box .param-badge {
    position: absolute;
    top: -10px; right: -10px;
    font-size: 0.65rem;
    font-weight: 600;
    background: var(--purple);
    color: #fff;
    padding: 3px 9px;
    border-radius: 12px;
  }

  /* ── Bar chart ── */
  .chart-area {
    margin-top: 12px;
  }
  .chart-title {
    font-size: 0.8rem;
    font-weight: 600;
    color: var(--text-dim);
    margin-bottom: 10px;
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }
  .bar-row {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 7px;
    height: 30px;
  }
  .bar-word {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.82rem;
    width: 80px;
    text-align: right;
    color: var(--text-dim);
    flex-shrink: 0;
  }
  .bar-track {
    flex: 1;
    height: 24px;
    background: var(--surface2);
    border-radius: 6px;
    overflow: hidden;
    position: relative;
  }
  .bar-fill {
    height: 100%;
    border-radius: 6px;
    transition: width 1s cubic-bezier(0.22, 1, 0.36, 1), background 0.6s;
    position: relative;
    min-width: 0;
  }
  .bar-fill.predicted {
    background: linear-gradient(90deg, var(--accent), var(--purple));
  }
  .bar-fill.target-fill {
    background: linear-gradient(90deg, var(--green), #34d399);
  }
  .bar-fill.loss-fill {
    background: linear-gradient(90deg, var(--red), var(--orange));
  }
  .bar-pct {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.75rem;
    color: var(--text-dim);
    width: 52px;
    text-align: left;
    flex-shrink: 0;
  }

  /* ── Dual chart layout ── */
  .dual-charts {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 24px;
    margin-top: 10px;
  }
  @media (max-width: 640px) {
    .dual-charts { grid-template-columns: 1fr; }
  }
  .chart-col {
    background: var(--surface2);
    border-radius: 10px;
    padding: 16px;
  }

  /* ── Loss display ── */
  .loss-display {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 18px;
    margin: 16px 0;
    flex-wrap: wrap;
  }
  .loss-box {
    text-align: center;
    padding: 16px 28px;
    border-radius: 12px;
    background: var(--surface2);
    border: 1px solid var(--border);
    min-width: 140px;
  }
  .loss-box .label {
    font-size: 0.7rem;
    text-transform: uppercase;
    letter-spacing: 0.06em;
    color: var(--text-dim);
    margin-bottom: 4px;
  }
  .loss-box .value {
    font-family: 'JetBrains Mono', monospace;
    font-size: 1.5rem;
    font-weight: 700;
  }
  .loss-box .value.high { color: var(--red); }
  .loss-box .value.low  { color: var(--green); }
  .loss-box .formula {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.72rem;
    color: var(--text-dim);
    margin-top: 4px;
  }

  .comlahoreon-arrow {
    font-size: 2rem;
    color: var(--text-dim);
    animation: pulseOpacity 1.5s ease-in-out infinite;
  }
  @keyframes pulseOpacity {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.3; }
  }

  /* ── Gradient / update visual ── */
  .update-flow {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 12px;
    margin: 14px 0;
    flex-wrap: wrap;
  }
  .flow-node {
    padding: 10px 18px;
    border-radius: 10px;
    font-size: 0.82rem;
    font-weight: 600;
    text-align: center;
    border: 1px solid var(--border);
  }
  .flow-arrow {
    color: var(--text-dim);
    font-size: 1.2rem;
  }
  .flow-node.loss-node   { background: rgba(248,113,113,0.1); border-color: rgba(248,113,113,0.3); color: var(--red); }
  .flow-node.grad-node   { background: rgba(251,146,60,0.1);  border-color: rgba(251,146,60,0.3);  color: var(--orange); }
  .flow-node.param-node  { background: rgba(167,139,250,0.1); border-color: rgba(167,139,250,0.3); color: var(--purple); }
  .flow-node.better-node { background: rgba(74,222,128,0.1);  border-color: rgba(74,222,128,0.3);  color: var(--green); }

  /* ── Before / After comlahoreon ── */
  .before-after {
    display: grid;
    grid-template-columns: 1fr auto 1fr;
    gap: 16px;
    align-items: start;
    margin-top: 10px;
  }
  @media (max-width: 640px) {
    .before-after { grid-template-columns: 1fr; }
    .before-after .ba-arrow { transform: rotate(90deg); }
  }
  .ba-col {
    background: var(--surface2);
    border-radius: 10px;
    padding: 16px;
  }
  .ba-col .ba-label {
    font-size: 0.72rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    font-weight: 600;
    margin-bottom: 10px;
  }
  .ba-col.before .ba-label { color: var(--red); }
  .ba-col.after  .ba-label { color: var(--green); }
  .ba-arrow {
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.8rem;
    color: var(--text-dim);
    padding-top: 40px;
  }

  /* ── Bottom nav ── */
  .bottom-nav {
    position: fixed;
    bottom: 0;
    left: 0; right: 0;
    display: flex;
    justify-content: center;
    gap: 12px;
    padding: 16px 20px;
    background: linear-gradient(transparent, var(--bg) 30%);
    z-index: 10;
  }
  .btn {
    font-family: 'Inter', sans-serif;
    font-size: 0.85rem;
    font-weight: 600;
    padding: 10px 28px;
    border-radius: 10px;
    border: 1px solid var(--border);
    background: var(--surface);
    color: var(--text);
    cursor: pointer;
    transition: all 0.25s;
  }
  .btn:hover { background: var(--surface2); }
  .btn.primary {
    background: var(--accent);
    border-color: var(--accent);
    color: #fff;
  }
  .btn.primary:hover {
    background: #5a7bef;
  }
  .btn:disabled {
    opacity: 0.35;
    cursor: not-allowed;
  }

  /* ── Annotation callout ── */
  .callout {
    display: flex;
    gap: 10px;
    padding: 12px 16px;
    border-radius: 10px;
    font-size: 0.82rem;
    line-height: 1.5;
    margin-top: 8px;
  }
  .callout.info {
    background: rgba(108,140,255,0.08);
    border: 1px solid rgba(108,140,255,0.18);
    color: #b8c7ff;
  }
  .callout.warn {
    background: rgba(251,146,60,0.08);
    border: 1px solid rgba(251,146,60,0.18);
    color: #fdc89b;
  }
  .callout.success {
    background: rgba(74,222,128,0.08);
    border: 1px solid rgba(74,222,128,0.18);
    color: #9eefbe;
  }
  .callout .icon { flex-shrink: 0; font-size: 1rem; }

  /* ── Math formula ── */
  .math {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.95rem;
    text-align: center;
    padding: 14px;
    background: var(--surface2);
    border-radius: 10px;
    margin: 10px 0;
    color: var(--yellow);
    letter-spacing: 0.02em;
  }

  /* ── Highlight span ── */
  .hl-accent { color: var(--accent); font-weight: 600; }
  .hl-green  { color: var(--green);  font-weight: 600; }
  .hl-red    { color: var(--red);    font-weight: 600; }
  .hl-orange { color: var(--orange); font-weight: 600; }
  .hl-purple { color: var(--purple); font-weight: 600; }
  .hl-yellow { color: var(--yellow); font-weight: 600; }

  /* ── Animated gradient line ── */
  .gradient-line {
    height: 2px;
    background: linear-gradient(90deg, var(--accent), var(--purple), var(--accent));
    background-size: 200% 100%;
    animation: shimmer 2s linear infinite;
    border-radius: 2px;
    margin: 6px 0;
  }
  @keyframes shimmer {
    0%   { background-position: 200% 0; }
    100% { background-position: -200% 0; }
  }

  /* vocab ticker for step 2 */
  .vocab-ticker {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    margin: 12px 0;
  }
  .vocab-chip {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.72rem;
    padding: 3px 10px;
    border-radius: 6px;
    background: var(--surface2);
    border: 1px solid var(--border);
    color: var(--text-dim);
    opacity: 0;
    animation: chipIn 0.3s forwards;
  }
  @keyframes chipIn {
    to { opacity: 1; }
  }
  .vocab-chip.highlight-chip {
    border-color: var(--green);
    color: var(--green);
    background: rgba(74,222,128,0.08);
  }

  /* backprop arrow animation */
  .backprop-arrows {
    display: flex;
    justify-content: center;
    gap: 4px;
    margin: 8px 0;
    font-size: 1.3rem;
  }
  .backprop-arrows span {
    color: var(--orange);
    animation: flowLeft 1s ease-in-out infinite;
    animation-delay: 0.45s;
  }
  .backprop-arrows span:nth-child(2) { animation-delay: 0.30s; }
  .backprop-arrows span:nth-child(3) { animation-delay: 0.15s; }
  .backprop-arrows span:nth-child(4) { animation-delay: 0.0s; }
  @keyframes flowLeft {
    0%, 100% { opacity: 0.2; }
    50% { opacity: 1; }
  }

  /* loss meter */
  .loss-meter {
    width: 100%;
    height: 10px;
    border-radius: 6px;
    background: var(--surface2);
    margin: 8px 0;
    overflow: hidden;
  }
  .loss-meter-fill {
    height: 100%;
    border-radius: 6px;
    transition: width 1.2s cubic-bezier(0.22, 1, 0.36, 1), background 0.6s;
  }
</style>
</head>
<body>

<div class="header">
  <h1>How Language Models Learn</h1>
  <p>Next-token prediction, loss, and parameter updates</p>
</div>

<div class="stage">
  <div class="step-dots" id="stepDots"></div>

  <!-- ════════════ STEP 0 : The Task ════════════ -->
  <div class="panel" id="panel-0">
    <div class="card">
      <span class="step-label">Step 1 — The Task</span>
      <h2>Predict the next token</h2>
      <p class="desc">During training, the model sees a sequence of tokens and must predict what comes next. This is the fundamental task that teaches language models to understand language.</p>

      <div class="context-row" id="ctx0">
        <span class="token highlight">"The</span>
        <span class="token highlight">capital</span>
        <span class="token highlight">of</span>
        <span class="token highlight">Pakistan</span>
        <span class="token highlight">is</span>
        <span class="token blank">???</span>
      </div>

      <div class="callout info">
        <span class="icon">i</span>
        <span>The model receives <span class="hl-accent">input context tokens</span> and must produce a probability for <em>every word in its vocabulary</em> as the next token. The training data already contains the answer — we just hide it and ask the model to guess.</span>
      </div>
    </div>
  </div>

  <!-- ════════════ STEP 1 : Forward Pass ════════════ -->
  <div class="panel" id="panel-1">
    <div class="card">
      <span class="step-label">Step 2 — Forward Pass</span>
      <h2>The model produces a probability distribution</h2>
      <p class="desc">The input tokens flow through billions of parameters — attention layers, feed-forward networks — and out comes a <span class="hl-accent">probability distribution over the entire vocabulary</span>.</p>

      <div class="context-row">
        <span class="token highlight">"The</span>
        <span class="token highlight">capital</span>
        <span class="token highlight">of</span>
        <span class="token highlight">Pakistan</span>
        <span class="token highlight">is</span>
      </div>

      <div class="arrow-down">↓</div>

      <div class="network-box">
        <div>
          <div class="nn-label">Transformer</div>
          <div class="nn-sub">attention + FFN layers</div>
        </div>
        <span class="param-badge" id="paramBadge">~7 B params</span>
      </div>

      <div class="arrow-down">↓</div>

      <div class="chart-area" id="predictedChart">
        <div class="chart-title">Model's predicted distribution (softmax output)</div>
        <!-- bars injected by JS -->
      </div>

      <div class="callout info">
        <span class="icon">i</span>
        <span>The final layer outputs a <span class="hl-accent">logit</span> for each vocabulary token, then a <span class="hl-accent">softmax</span> converts these to probabilities that sum to 1. An untrained model spreads probability almost evenly — it's basically guessing randomly.</span>
      </div>
    </div>
  </div>

  <!-- ════════════ STEP 2 : Target Distribution ════════════ -->
  <div class="panel" id="panel-2">
    <div class="card">
      <span class="step-label">Step 3 — The Target</span>
      <h2>What the model <em>should</em> have predicted</h2>
      <p class="desc">We know the correct next token from the training data. The <span class="hl-green">target distribution</span> puts 100% probability on the correct answer.</p>

      <div class="dual-charts">
        <div class="chart-col">
          <div class="chart-title" style="color:var(--accent)">Model's prediction</div>
          <div id="dualPredicted"></div>
        </div>
        <div class="chart-col">
          <div class="chart-title" style="color:var(--green)">Target (ground truth)</div>
          <div id="dualTarget"></div>
        </div>
      </div>

      <div class="callout warn">
        <span class="icon">!</span>
        <span>The model only gave <span class="hl-accent" id="lahorePctText">8%</span> to <span class="hl-green">"lahore"</span>, but the target says it should be <span class="hl-green">100%</span>. That gap is what the <span class="hl-red">loss function</span> measures.</span>
      </div>
    </div>
  </div>

  <!-- ════════════ STEP 3 : Loss Computation ════════════ -->
  <div class="panel" id="panel-3">
    <div class="card">
      <span class="step-label">Step 4 — Compute the Loss</span>
      <h2>Cross-entropy loss: how wrong is the model?</h2>
      <p class="desc">The loss function measures the gap between the model's predicted distribution and the target. For next-token prediction, we use <span class="hl-yellow">cross-entropy loss</span>.</p>

      <div class="math" id="lossFormula">
        Loss = −log( P<sub>model</sub>(" lahore ") ) = −log(<span id="lossPval">0.08</span>) = <span id="lossResult" class="hl-red">2.53</span>
      </div>

      <div class="loss-display">
        <div class="loss-box">
          <div class="label">P(lahore)</div>
          <div class="value high" id="lossProbDisplay">0.08</div>
        </div>
        <div class="comlahoreon-arrow">→</div>
        <div class="loss-box">
          <div class="label">Loss</div>
          <div class="value high" id="lossValueDisplay">2.53</div>
          <div class="formula">−log(p)</div>
        </div>
      </div>

      <div style="max-width:400px; margin:0 auto;">
        <div style="display:flex; justify-content:space-between; font-size:0.72rem; color:var(--text-dim); margin-bottom:2px;">
          <span class="hl-green">low loss (good)</span>
          <span class="hl-red">high loss (bad)</span>
        </div>
        <div class="loss-meter">
          <div class="loss-meter-fill" id="lossMeter" style="width:80%; background: linear-gradient(90deg, var(--green), var(--yellow), var(--red));"></div>
        </div>
      </div>

      <div class="callout info">
        <span class="icon">i</span>
        <span><span class="hl-yellow">Intuition:</span> if the model gave 100% to "lahore", loss = −log(1) = <span class="hl-green">0</span> (perfect). If only 1%, loss = −log(0.01) = <span class="hl-red">4.6</span> (terrible). The loss is a single number that captures "how surprised the model is by the right answer."</span>
      </div>
    </div>
  </div>

  <!-- ════════════ STEP 4 : Backpropagation ════════════ -->
  <div class="panel" id="panel-4">
    <div class="card">
      <span class="step-label">Step 5 — Backpropagation</span>
      <h2>Compute gradients and update parameters</h2>
      <p class="desc">The loss signal flows <em>backwards</em> through the network. For each parameter, we compute: "how much would changing this parameter reduce the loss?" Then we nudge every parameter in that direction.</p>

      <div class="update-flow">
        <div class="flow-node loss-node">Loss = 2.53</div>
        <div class="flow-arrow">→</div>
        <div class="flow-node grad-node">∂Loss/∂θ<br><small>compute gradients</small></div>
        <div class="flow-arrow">→</div>
        <div class="flow-node param-node">θ = θ − η·∇Loss<br><small>update params</small></div>
      </div>

      <div class="backprop-arrows">
        <span>◂</span><span>◂</span><span>◂</span><span>◂</span>
        <span style="font-size:0.8rem; color:var(--text-dim); animation:none; margin-left:4px;">gradients flow backward</span>
      </div>

      <div class="math">
        θ<sub>new</sub> = θ<sub>old</sub> − η · ∂Loss/∂θ
      </div>

      <div class="callout info">
        <span class="icon">i</span>
        <span><span class="hl-purple">η (eta)</span> is the <strong>learning rate</strong> — a small number (e.g., 1e-4) that controls how big each update step is. Too large → unstable. Too small → slow learning. The <span class="hl-orange">gradient ∂Loss/∂θ</span> tells us the direction and magnitude of the adjustment needed for each parameter.</span>
      </div>
    </div>
  </div>

  <!-- ════════════ STEP 5 : Result ════════════ -->
  <div class="panel" id="panel-5">
    <div class="card">
      <span class="step-label">Step 6 — After Update</span>
      <h2>The model improves!</h2>
      <p class="desc">After updating the parameters, the model assigns <em>more</em> probability to the correct token. Repeat this millions of times across a massive dataset, and the model learns language.</p>

      <div class="before-after">
        <div class="ba-col before">
          <div class="ba-label">Before update</div>
          <div id="beforeBars"></div>
        </div>
        <div class="ba-arrow">→</div>
        <div class="ba-col after">
          <div class="ba-label">After update</div>
          <div id="afterBars"></div>
        </div>
      </div>

      <div class="loss-display">
        <div class="loss-box">
          <div class="label">Loss before</div>
          <div class="value high">2.53</div>
        </div>
        <div class="comlahoreon-arrow">→</div>
        <div class="loss-box">
          <div class="label">Loss after</div>
          <div class="value low" id="lossAfterVal">1.27</div>
        </div>
      </div>

      <div class="callout success">
        <span class="icon">✓</span>
        <span>The model now assigns <span class="hl-green" id="afterlahorePct">28%</span> to "lahore" (up from <span class="hl-red">8%</span>). The loss dropped from <span class="hl-red">2.53</span> to <span class="hl-green" id="afterLossText">1.27</span>. After many more steps over many examples, the model will learn to confidently predict "lahore" in this context — and generalize this knowledge to countless other facts.</span>
      </div>
    </div>
  </div>

  <!-- ════════════ STEP 6 : Full Loop ════════════ -->
  <div class="panel" id="panel-6">
    <div class="card">
      <span class="step-label">The Big Picture</span>
      <h2>Training = repeating this loop trillions of times</h2>
      <p class="desc">Every token in the training corpus becomes a learning signal. The model sees text, predicts the next token, measures how wrong it was, and adjusts. Over time, it builds a rich understanding of language, facts, reasoning, and more.</p>

      <div class="update-flow" style="flex-wrap: wrap; gap: 10px;">
        <div class="flow-node" style="background:rgba(108,140,255,0.08); border-color:rgba(108,140,255,0.2); color:var(--accent);">Input tokens</div>
        <div class="flow-arrow">→</div>
        <div class="flow-node param-node">Forward pass</div>
        <div class="flow-arrow">→</div>
        <div class="flow-node" style="background:rgba(108,140,255,0.08); border-color:rgba(108,140,255,0.2); color:var(--accent);">Predicted dist.</div>
        <div class="flow-arrow">→</div>
        <div class="flow-node loss-node">Loss</div>
        <div class="flow-arrow">→</div>
        <div class="flow-node grad-node">Gradients</div>
        <div class="flow-arrow">→</div>
        <div class="flow-node better-node">Update θ</div>
      </div>

      <div class="gradient-line"></div>

      <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(180px,1fr)); gap:12px; margin-top:14px;">
        <div class="callout info" style="margin:0;">
          <span><strong>Dataset:</strong> trillions of tokens from books, web, code…</span>
        </div>
        <div class="callout info" style="margin:0;">
          <span><strong>Steps:</strong> millions of gradient updates</span>
        </div>
        <div class="callout info" style="margin:0;">
          <span><strong>Result:</strong> a model that can predict (and generate) fluent text</span>
        </div>
      </div>

      <div class="callout success" style="margin-top: 14px;">
        <span class="icon">✓</span>
        <span><strong>Key insight:</strong> The entire capability of an LLM — writing code, answering questions, reasoning — emerges from this simple loop: <em>predict the next token, measure the error, update, repeat.</em></span>
      </div>
    </div>
  </div>

</div>

<div class="bottom-nav">
  <button class="btn" id="btnPrev" disabled>← Back</button>
  <button class="btn primary" id="btnNext">Next →</button>
</div>

<script>
// ── Data ──
const VOCAB = [
  { word: 'lahore',   predicted: 0.08, target: 1.00, after: 0.28 },
  { word: 'London',  predicted: 0.11, target: 0.00, after: 0.06 },
  { word: 'the',     predicted: 0.14, target: 0.00, after: 0.09 },
  { word: 'Berlin',  predicted: 0.06, target: 0.00, after: 0.03 },
  { word: 'a',       predicted: 0.10, target: 0.00, after: 0.07 },
  { word: 'Lyon',    predicted: 0.04, target: 0.00, after: 0.03 },
  { word: 'Rome',    predicted: 0.05, target: 0.00, after: 0.02 },
  { word: 'not',     predicted: 0.07, target: 0.00, after: 0.05 },
  { word: '...',     predicted: 0.35, target: 0.00, after: 0.37 },
];

const TOTAL_STEPS = 7;
let currentStep = 0;

// ── DOM helpers ──
const $ = (sel) => document.querySelector(sel);
const $$ = (sel) => document.querySelectorAll(sel);

function buildDots() {
  const c = $('#stepDots');
  for (let i = 0; i < TOTAL_STEPS; i++) {
    const d = document.createElement('div');
    d.className = 'dot' + (i === 0 ? ' active' : '');
    d.dataset.idx = i;
    d.addEventListener('click', () => goTo(i));
    c.appendChild(d);
  }
}

function buildBars(container, data, type, animate = true) {
  const el = typeof container === 'string' ? $(container) : container;
  el.innerHTML = '';
  const maxPct = Math.max(...data.map(d => d.value));
  data.forEach((d, i) => {
    const row = document.createElement('div');
    row.className = 'bar-row';

    const wordEl = document.createElement('div');
    wordEl.className = 'bar-word';
    wordEl.textContent = d.word;
    if (d.word === 'lahore') wordEl.style.color = 'var(--green)';

    const track = document.createElement('div');
    track.className = 'bar-track';

    const fill = document.createElement('div');
    fill.className = 'bar-fill ' + type;
    const pctWidth = d.value > 0 ? Math.max(d.value / 1.0 * 100, 1.5) : 0;
    if (animate) {
      fill.style.width = '0%';
      setTimeout(() => { fill.style.width = pctWidth + '%'; }, 80 + i * 60);
    } else {
      fill.style.width = pctWidth + '%';
    }

    track.appendChild(fill);

    const pctEl = document.createElement('div');
    pctEl.className = 'bar-pct';
    pctEl.textContent = (d.value * 100).toFixed(1) + '%';

    row.appendChild(wordEl);
    row.appendChild(track);
    row.appendChild(pctEl);
    el.appendChild(row);
  });
}

function predictedData() { return VOCAB.map(v => ({ word: v.word, value: v.predicted })); }
function targetData()    { return VOCAB.map(v => ({ word: v.word, value: v.target })); }
function afterData()     { return VOCAB.map(v => ({ word: v.word, value: v.after })); }

// ── Step transitions ──
function enterStep(s) {
  $$('.panel').forEach(p => p.classList.remove('active'));
  $(`#panel-${s}`).classList.add('active');

  $$('.dot').forEach((d, i) => {
    d.classList.remove('active');
    d.classList.toggle('done', i < s);
    if (i === s) d.classList.add('active');
  });

  $('#btnPrev').disabled = s === 0;
  $('#btnNext').textContent = s === TOTAL_STEPS - 1 ? 'Restart ↺' : 'Next →';

  // populate dynamic content per step
  if (s === 1) {
    buildBars('#predictedChart', predictedData(), 'predicted');
  }
  if (s === 2) {
    buildBars('#dualPredicted', predictedData(), 'predicted');
    buildBars('#dualTarget', targetData(), 'target-fill');
    const lahorePred = VOCAB[0].predicted;
    $('#lahorePctText').textContent = (lahorePred * 100).toFixed(0) + '%';
  }
  if (s === 3) {
    const p = VOCAB[0].predicted;
    const loss = -Math.log(p);
    $('#lossPval').textContent = p.toFixed(2);
    $('#lossResult').textContent = loss.toFixed(2);
    $('#lossProbDisplay').textContent = p.toFixed(2);
    $('#lossValueDisplay').textContent = loss.toFixed(2);
    // animate meter
    const meterPct = Math.min(loss / 5 * 100, 100);
    const meter = $('#lossMeter');
    meter.style.width = '0%';
    setTimeout(() => { meter.style.width = meterPct + '%'; }, 200);
  }
  if (s === 5) {
    buildBars('#beforeBars', predictedData(), 'predicted');
    setTimeout(() => {
      buildBars('#afterBars', afterData(), 'target-fill');
    }, 300);
    const afterLoss = -Math.log(VOCAB[0].after);
    $('#lossAfterVal').textContent = afterLoss.toFixed(2);
    $('#afterlahorePct').textContent = (VOCAB[0].after * 100).toFixed(0) + '%';
    $('#afterLossText').textContent = afterLoss.toFixed(2);
  }
}

function goTo(s) {
  if (s < 0 || s >= TOTAL_STEPS) return;
  currentStep = s;
  enterStep(s);
}

// ── Controls ──
$('#btnNext').addEventListener('click', () => {
  if (currentStep === TOTAL_STEPS - 1) {
    goTo(0);
  } else {
    goTo(currentStep + 1);
  }
});
$('#btnPrev').addEventListener('click', () => goTo(currentStep - 1));

document.addEventListener('keydown', (e) => {
  if (e.key === 'ArrowRight' || e.key === ' ') { e.preventDefault(); $('#btnNext').click(); }
  if (e.key === 'ArrowLeft') { e.preventDefault(); $('#btnPrev').click(); }
});

// ── Init ──
buildDots();
enterStep(0);
</script>
</body>
</html>
